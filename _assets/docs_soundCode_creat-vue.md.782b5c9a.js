import{q as e,g as n,l as r,j as t,k as a,K as i}from"./common-1984dd55.js";const s='{"title":"【源码计划第八期】create-vue","frontmatter":{"date":"2021-12-01","title":"【源码计划第八期】create-vue","tags":["源码"],"describe":"学习cli脚本编写"},"headers":[{"level":3,"title":"1. 阅读前准备","slug":"_1-阅读前准备"},{"level":3,"title":"2. 使用它","slug":"_2-使用它"},{"level":3,"title":"3. 阅读源码","slug":"_3-阅读源码"},{"level":3,"title":"4. 总结","slug":"_4-总结"}],"relativePath":"docs/soundCode/creat-vue.md","lastUpdated":1646063815125.8818}';var o={};const p=t("blockquote",null,[t("p",null,"继续跟上川哥举办的阅读源码活动~"),t("p",null,[a("掘金原文："),t("a",{href:"https://juejin.cn/post/7018344866811740173#heading-4",target:"_blank",rel:"noopener noreferrer"},"https://juejin.cn/post/7018344866811740173#heading-4")])],-1),c=t("h3",{id:"_1-阅读前准备"},[t("a",{class:"header-anchor",href:"#_1-阅读前准备","aria-hidden":"true"},"#"),a(" 1. 阅读前准备")],-1),d=t("p",null,"这是一个vite+vue3的脚手架，目前还属于比较初版的状态，README也不是很全面，大致浏览源码后，主要有以下几点可以好好学习下：",-1),l=t("ul",null,[t("li",null,"npm init"),t("li",null,"交互式初始化")],-1),f=i('<ul><li>根据选择配置生成不同模板</li><li>模板生成原理</li></ul><p>项目地址： <a href="https://github.com/vuejs/create-vue" target="_blank" rel="noopener noreferrer">https://github.com/vuejs/create-vue</a></p><p>这是一个我之前完全没有接触过的项目，文章中间会拓展很多<code>create-Vue</code>之外的内容，最终希望自己可以通过阅读源码，产出cli工具，方便在工作中项目开发</p><h3 id="_2-使用它"><a class="header-anchor" href="#_2-使用它" aria-hidden="true">#</a> 2. 使用它</h3><p>使用起来非常简单，只需要 npm init 即可</p><div class="language-"><pre><code>npm init vue@next\n</code></pre></div><p>接着输入项目名、确认是否需要额外的配置项，即可生成一个完整的项目</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f538e0ebb2f745f99bd6f4c1383f3dd2~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>最终只需要<code>cd vue-project</code>、<code>npm install</code>、<code>npm run dev</code>即可非常急速的打开这个项目</p><h3 id="_3-阅读源码"><a class="header-anchor" href="#_3-阅读源码" aria-hidden="true">#</a> 3. 阅读源码</h3><p>首先克隆项目、安装依赖</p><div class="language-"><pre><code>git clone https://github.com/vuejs/create-vue.git\nnpm install\n</code></pre></div><p>进入package.json看看可执行的脚本</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75bebe4d2d9b431a9111abfd77fa19fa~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>看到几个熟悉的脚本：</p><ul><li>build:将脚手架主文件index.js打包输出成outfile.cjs</li><li>test:执行测试用例</li></ul><p>先从执行test调试起！</p><h4 id="_3-1-snapshot"><a class="header-anchor" href="#_3-1-snapshot" aria-hidden="true">#</a> 3.1 snapshot</h4><p>执行<code>npm run test</code>时，会先执行<code>npm run pretest</code> （第三期的知识点：npm钩子函数）</p><p>看看snapshot中都做了什么事情~</p><p>进入snapshot发现这里做了两件事：</p><ul><li>调用node的子进程方法中同步进程函数，根据index.js文件中的规则，在playground文件夹下创建不同的模板，方便调用test.js进行测试</li><li>根据五种拓展属性，进行二进制的排列组合，最终会生成31种+default一共32种组合</li></ul><p>这里主要看一下生成模板的方法：</p><div class="language-"><pre><code>// 获取基本路径\nconst __dirname = path\n  .dirname(new URL(import.meta.url).pathname)\n  .substring(process.platform === &#39;win32&#39; ? 1 : 0)\n\n\n// 这里的bin是执行打包后的index.js文件生成项目模板，方便调试就改成了index.js\n// const bin = path.resolve(__dirname, &#39;./outfile.cjs&#39;)\nconst bin = path.resolve(__dirname, &#39;./index.js&#39;)\n// 目标文件夹\nconst playgroundDir = path.resolve(__dirname, &#39;./playground/&#39;)\n\nfunction createProjectWithFeatureFlags(flags) {\n  // flags会以数组的形式传入，如果出现多个参数时，用-分割\n  const projectName = flags.join(&#39;-&#39;)\n  console.log(`Creating project ${projectName}`)\n  // 调用子进程\n  // 这部分会生成一个类似于 node ./index.js --typescript --force的命令\n  // 主要就是调用index.js中的init方法生成模板\n  const { status } = spawnSync(\n    &#39;node&#39;,\n    [bin, projectName, ...flags.map((flag) =&gt; `--${flag}`), &#39;--force&#39;],\n    {\n      cwd: playgroundDir,\n      stdio: [&#39;pipe&#39;, &#39;pipe&#39;, &#39;inherit&#39;]\n    }\n  )\n\n  if (status !== 0) {\n    process.exit(status)\n  }\n}\n</code></pre></div><p>这里主要的灵魂就是调起子进程，执行文件生成项目模板</p><p>接着看看具体是怎么生成模板的</p><h4 id="_3-2-index-js"><a class="header-anchor" href="#_3-2-index-js" aria-hidden="true">#</a> 3.2 index.js</h4><p>这部分主要做了以下几件事：</p><ul><li>支持feature Flags直接生成模板</li><li>调用<code>prompts</code>进行交互式配置</li></ul>',29),u=i('<ul><li>根据配置调用render()渲染模板</li><li>根据配置生成不同README</li></ul><h5 id="_3-2-1-交互式"><a class="header-anchor" href="#_3-2-1-交互式" aria-hidden="true">#</a> 3.2.1 交互式</h5><p>首先在script中添加一行<code>&quot;dev&quot;:&quot;node index.js&quot;</code>运行调试，开始我们的debug</p><p>最先进入的会是一段交互式配置，这部分代码将做省略，保留一些调用了工具方法的配置</p><div class="language-"><pre><code>let result = {}\n\n  try {\n    result = await prompts(\n      [\n        {\n          name: &#39;shouldOverwrite&#39;,\n          // 这里判断了一次改名称是否可写入\n          type: () =&gt; (canSafelyOverwrite(targetDir) || forceOverwrite ? null : &#39;confirm&#39;),\n          message: () =&gt; {\n            const dirForPrompt =\n              targetDir === &#39;.&#39; ? &#39;Current directory&#39; : `Target directory &quot;${targetDir}&quot;`\n\n            return `${dirForPrompt} is not empty. Remove existing files and continue?`\n          }\n        },\n        {\n          name: &#39;overwriteChecker&#39;,\n          type: (prev, values = {}) =&gt; {\n            if (values.shouldOverwrite === false) {\n              throw new Error(red(&#39;✖&#39;) + &#39; Operation cancelled&#39;)\n            }\n            return null\n          }\n        },\n        {\n          name: &#39;packageName&#39;,\n          // 这里判断了一次当前包名称是否合法\n          type: () =&gt; (isValidPackageName(targetDir) ? null : &#39;text&#39;),\n          message: &#39;Package name:&#39;,\n          // 这里调用了转换包名工具\n          initial: () =&gt; toValidPackageName(targetDir),\n          validate: (dir) =&gt; isValidPackageName(dir) || &#39;Invalid package.json name&#39;\n        },\n      ],\n    )\n  } catch (cancelled) {\n    console.log(cancelled.message)\n    process.exit(1)\n  }\n</code></pre></div><p>这三个工具函数也比较简单，通过正则或node方法，进行简单的判断</p><div class="language-"><pre><code>// 使用正则判断当前包名是否合法，没有采用validate-npm-package-name（第七期检测包名是否合法的工具），自己实现了检测功能\nfunction isValidPackageName(projectName) {\n  return /^(?:@[a-z0-9-*~][a-z0-9-*._~]*/)?[a-z0-9-~][a-z0-9-._~]*$/.test(projectName)\n}\n\n// 对传入的包名称进行转写\nfunction toValidPackageName(projectName) {\n  return projectName\n    .trim()\n    .toLowerCase()\n    .replace(/\\s+/g, &#39;-&#39;)\n    .replace(/^[._]/, &#39;&#39;)\n    .replace(/[^a-z0-9-~]+/g, &#39;-&#39;)\n}\n\n// 使用node的内置方法，判断本地是否存在该名称的文件夹，以及该文件夹下是否有文件\nfunction canSafelyOverwrite(dir) {\n  return !fs.existsSync(dir) || fs.readdirSync(dir).length === 0\n}\n</code></pre></div><p>在执行完所有的交互配置后，会在文件内部<code>result</code>属性中记录最终的配置结果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b95f5d4163047e7804616c7a7a411f0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h5 id="_3-2-2生成模板"><a class="header-anchor" href="#_3-2-2生成模板" aria-hidden="true">#</a> 3.2.2生成模板</h5><p>生成完所有配置后，会根据配置进行模板生成，具体生成顺序如下：</p><ul><li><p>生成base基础模板</p></li><li><p>根据不同配置需求，继续添加合并模板</p></li><li><p>如果需要typeScript，将所有.js文件改成.ts，并将jsconfig.json改成tsconfig.json</p></li><li><p>如果不需要测试，就把测试相关文件删除</p></li><li><p>生成README文档</p></li></ul><p>第一步！生成模板</p><div class="language-"><pre><code>import renderTemplate from &#39;./utils/renderTemplate.js&#39;\n\n// 设置模板文件地址\nconst templateRoot = path.resolve(__dirname, &#39;template&#39;)\n\n// 生成模板主函数\nconst render = function render(templateName) {\n  // 具体要生成的模板目录下的子目录\n  const templateDir = path.resolve(templateRoot, templateName)\n  // 传入子目录和项目的地址\n  renderTemplate(templateDir, root)\n}\n\n// Render base template\nrender(&#39;base&#39;)\n</code></pre></div><p>接着看看具体生成模板的流程，同样也分成三部分：</p><ul><li>递归copy所有的模板文件进项目中</li><li>如果文件中存在package.json，进行对象合并</li></ul>',16),g=i('<ul><li>将以<code>_</code>开头的文件替换成<code>.</code>开头</li></ul><p>第一部分：处理文件夹</p><div class="language-"><pre><code>const stats = fs.statSync(src)\n// 如果传入的src是文件夹，就递归调用renderTemplate处理文件夹下的每一个文件\nif (stats.isDirectory()) {\n  // if it&#39;s a directory, render its subdirectories and files recursively\n  fs.mkdirSync(dest, { recursive: true })\n  for (const file of fs.readdirSync(src)) {\n    renderTemplate(path.resolve(src, file), path.resolve(dest, file))\n  }\n  return\n}\n</code></pre></div><p>第二部分：处理<code>package.json</code>文件：</p><div class="language-"><pre><code>import deepMerge from &#39;./deepMerge.js&#39;\nimport sortDependencies from &#39;./sortDependencies.js&#39;\nconst filename = path.basename(src)\n\n// 如果文件名称为package.json且该文件已经存在\nif (filename === &#39;package.json&#39; &amp;&amp; fs.existsSync(dest)) {\n  // 存放需要操作的文件\n  const existing = JSON.parse(fs.readFileSync(dest))\n  // 存放需要拷贝的文件\n  const newPackage = JSON.parse(fs.readFileSync(src))\n  // 重点！：调用了两个函数，deepMerge用于处理两个json的合并，sortDependencies用于排序\n  const pkg = sortDependencies(deepMerge(existing, newPackage))\n  fs.writeFileSync(dest, JSON.stringify(pkg, null, 2) + &#39;\\n&#39;)\n  return\n}\n</code></pre></div><p>处理文件过程中使用到两个函数：<code>deepMerge</code>、<code>sortDependencies</code>，分别用于处理合并和排序</p><p>继续深入看<code>deepMerge</code>，这部分主要是对 对象和数组的处理：</p><ul><li>处理对象时，通过递归赋值进行处理</li><li>处理数组时，通过解构合并进行处理</li></ul><div class="language-"><pre><code>const isObject = (val) =&gt; val &amp;&amp; typeof val === &#39;object&#39;\nconst mergeArrayWithDedupe = (a, b) =&gt; Array.from(new Set([...a, ...b]))\n\n/**\n * Recursively merge the content of the new object to the existing one\n * @param {Object} target the existing object\n * @param {Object} obj the new object\n */\nfunction deepMerge(target, obj) {\n  // 循环传入的template中的模板\n  for (const key of Object.keys(obj)) {\n    const oldVal = target[key]\n    const newVal = obj[key]\n\t\t//如果参数的内容是数组\n    if (Array.isArray(oldVal) &amp;&amp; Array.isArray(newVal)) {\n      // 使用解构进行合并\n      target[key] = mergeArrayWithDedupe(oldVal, newVal)\n    } else if (isObject(oldVal) &amp;&amp; isObject(newVal)) {\n      // 如果参数内容是对象，就继续递归处理，直到是内容\n      target[key] = deepMerge(oldVal, newVal)\n    } else {\n      // 直接为内容时，直接赋值\n      target[key] = newVal\n    }\n  }\n\n  return target\n}\n</code></pre></div><p>合并后继续做排序的处理，这时会进入到<code>sortDependencies</code>函数中</p><div class="language-"><pre><code>export default function sortDependencies(packageJson) {\n  const sorted = {}\n\t// 依照数组中元素的顺序，进行遍历排序\n  const depTypes = [&#39;dependencies&#39;, &#39;devDependencies&#39;, &#39;peerDependencies&#39;, &#39;optionalDependencies&#39;]\n\n  for (const depType of depTypes) {\n    if (packageJson[depType]) {\n      sorted[depType] = {}\n\n      Object.keys(packageJson[depType])\n        .sort()\n        .forEach((name) =&gt; {\n          sorted[depType][name] = packageJson[depType][name]\n        })\n    }\n  }\n\n  return {\n    ...packageJson,\n    ...sorted\n  }\n}\n</code></pre></div><p>第三部分，修改文件名</p><p>项目中以<code>.</code>开头的文件都是一些配置文件，而如果直接在模板中存放这些文件时，可能会造成编译器识别的一些影响，所以在模板中，都以<code>_</code>开头存放文件，在生成模板文件时再进行改名</p><p>这里比较简单，就是一个node.path的调用</p><div class="language-"><pre><code>if (filename.startsWith(&#39;_&#39;)) {\n  // rename `_file` to `.file`\n  dest = path.resolve(path.dirname(dest), filename.replace(/^_/, &#39;.&#39;))\n}\n</code></pre></div><p>至此，一个模板已经完全生成！</p><p>让我们进入简单的第二步：根据自定义配置继续生成模板</p><p>这部分比较简单，从之前的配置信息中，生成调用不同路径下的文件，继续生成模板</p><div class="language-"><pre><code>  // Add configs.\n  if (needsJsx) {\n    render(&#39;config/jsx&#39;)\n  }\n  if (needsRouter) {\n    render(&#39;config/router&#39;)\n  }\n  if (needsVuex) {\n    render(&#39;config/vuex&#39;)\n  }\n  if (needsTests) {\n    render(&#39;config/cypress&#39;)\n  }\n  if (needsTypeScript) {\n    render(&#39;config/typescript&#39;)\n  }\n\n  // Render code template.\n  // prettier-ignore\n  const codeTemplate =\n    (needsTypeScript ? &#39;typescript-&#39; : &#39;&#39;) +\n    (needsRouter ? &#39;router&#39; : &#39;default&#39;)\n  render(`code/${codeTemplate}`)\n\n  // Render entry file (main.js/ts).\n  if (needsVuex &amp;&amp; needsRouter) {\n    render(&#39;entry/vuex-and-router&#39;)\n  } else if (needsVuex) {\n    render(&#39;entry/vuex&#39;)\n  } else if (needsRouter) {\n    render(&#39;entry/router&#39;)\n  } else {\n    render(&#39;entry/default&#39;)\n  }\n</code></pre></div><p>继续进入第三步：使用<code>typeScript</code></p><p>这部分比较简单，递归遍历所有后缀为<code>.js</code>的文件，替换成<code>.ts</code>，以及将jsconfig.json转换成tsconfig.json（简单粗暴），在这个过程中调用了<code>preOrderDirectoryTraverse</code>方法，我们重点细看这部分方法</p><div class="language-"><pre><code>if (needsTypeScript) {\n  // rename all `.js` files to `.ts`\n  // rename jsconfig.json to tsconfig.json\n  preOrderDirectoryTraverse(\n    root,\n    () =&gt; {},\n    (filepath) =&gt; {\n      // 如果后缀为.js\n      if (filepath.endsWith(&#39;.js&#39;)) {\n        // 进行替换\n        fs.renameSync(filepath, filepath.replace(/.js$/, &#39;.ts&#39;))\n        // 同时如果为jsconfig.json\n      } else if (path.basename(filepath) === &#39;jsconfig.json&#39;) {\n        // 也进行替换\n        fs.renameSync(filepath, filepath.replace(/jsconfig.json$/, &#39;tsconfig.json&#39;))\n      }\n    }\n  )\n\n  // Rename entry in `index.html`\n  const indexHtmlPath = path.resolve(root, &#39;index.html&#39;)\n  const indexHtmlContent = fs.readFileSync(indexHtmlPath, &#39;utf8&#39;)\n  fs.writeFileSync(indexHtmlPath, indexHtmlContent.replace(&#39;src/main.js&#39;, &#39;src/main.ts&#39;))\n}\n</code></pre></div><p>继续进入<code>preOrderDirectoryTraverse</code></p><div class="language-"><pre><code>// 这里主要是做文件夹和文件的递归\nexport function preOrderDirectoryTraverse(dir, dirCallback, fileCallback) {\n  // 首先读取该路径下所有文件\n  for (const filename of fs.readdirSync(dir)) {\n    const fullpath = path.resolve(dir, filename)\n    // 如果是一个文件夹\n    if (fs.lstatSync(fullpath).isDirectory()) {\n      // 执行文件夹的回调\n      dirCallback(fullpath)\n      // in case the dirCallback removes the directory entirely\n      // 如果文件夹没有被删除，还存在\n      if (fs.existsSync(fullpath)) {\n        // 继续递归里面的文件\n        preOrderDirectoryTraverse(fullpath, dirCallback, fileCallback)\n      }\n      continue\n    }\n    // 执行文件的回调\n    fileCallback(fullpath)\n  }\n}\n</code></pre></div><p>至此，ts的转化也已经完成~</p><p>进入第四步：删除测试相关文件</p><p>调用<code>fs.rmdirSync</code>删除文件夹时，只能删除空文件夹，所以需要通过遍历文件夹以及文件夹内所有的文件，先删除文件，再删除文件夹</p><p>这里同样调用了<code>preOrderDirectoryTraverse</code>方法，</p><p>并且在文件夹回调函数中调用了<code>emptyDir</code>方法</p><div class="language-"><pre><code>if (!needsTests) {\n  preOrderDirectoryTraverse(\n    root,\n    (dirpath) =&gt; {\n      const dirname = path.basename(dirpath)\n\t\t\t// 如果文件夹为测试文件夹\n      if (dirname === &#39;cypress&#39; || dirname === &#39;__tests__&#39;) {\n        // 调用方法进行删除\n        emptyDir(dirpath)\n        fs.rmdirSync(dirpath)\n      }\n    },\n    () =&gt; {}\n  )\n}\n\n\nfunction emptyDir(dir) {\n  // 继续文件夹递归\n  postOrderDirectoryTraverse(\n    dir,\n    (dir) =&gt; fs.rmdirSync(dir),\n    (file) =&gt; fs.unlinkSync(file)\n  )\n}\n\nexport function postOrderDirectoryTraverse(dir, dirCallback, fileCallback) {\n  for (const filename of fs.readdirSync(dir)) {\n    const fullpath = path.resolve(dir, filename)\n    // 如果是文件夹，就继续递归\n    if (fs.lstatSync(fullpath).isDirectory()) {\n      postOrderDirectoryTraverse(fullpath, dirCallback, fileCallback)\n      dirCallback(fullpath)\n      continue\n    }\n    // 如果是文件，调用文件回调函数\n    fileCallback(fullpath)\n  }\n}\n</code></pre></div><p>最后第五步：生成README</p><div class="language-"><pre><code>fs.writeFileSync(\n  path.resolve(root, &#39;README.md&#39;),\n  generateReadme({\n    projectName: result.projectName || defaultProjectName,\n    packageManager,\n    needsTypeScript,\n    needsTests\n  })\n)\n</code></pre></div><h3 id="_4-总结"><a class="header-anchor" href="#_4-总结" aria-hidden="true">#</a> 4. 总结</h3><p>这次的cli源码阅读能感知到自己的知识短板，在执行流程能大概读懂外，对于很多封装方法中涉及到的算法、node指令，阅读起来还是比较吃力，需要反复使用debug和查阅node文档进行理解。</p><p>结合第6期，可以发现在制作脚手架、开源库时，有很多工具库可以直接使用，加快开发速度，例如<code>prompts</code>交互式生成配置，就是一个很不错的库</p><p>后续还会反复阅读这个库的源码，学习和借鉴制作cli的流程，开发一个在工作团队内部可以方便快速拉取模板代码库的cli，并总结一篇制作cli工具的文章</p>',36);o.render=function(t,a,i,s,o,m){return e(),n("div",null,[p,c,d,l,r(""),f,r(""),u,r(""),g])};export{s as __pageData,o as default};
