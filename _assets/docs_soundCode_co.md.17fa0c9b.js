import{q as e,g as n,l as r,K as t,j as o,k as a}from"./common-1984dd55.js";const l='{"title":"【源码第三期】简单理解co源码及实现","frontmatter":{"date":"2021-11-06","title":"【源码第三期】简单理解co源码及实现","tags":["源码"],"describe":"浅析 co源码"},"headers":[{"level":3,"title":"1. 什么是CO","slug":"_1-什么是co"},{"level":3,"title":"2. 阅读前准备","slug":"_2-阅读前准备"},{"level":3,"title":"3. 开始阅读","slug":"_3-开始阅读"},{"level":3,"title":"4. 实现简单co","slug":"_4-实现简单co"},{"level":3,"title":"","slug":""},{"level":3,"title":"总结","slug":"总结"}],"relativePath":"docs/soundCode/co.md","lastUpdated":1646063815125.8818}';var i={};const c=t('<blockquote><p>更多的源码阅读文章更新在自己的语雀：<a href="https://www.yuque.com/shouhu-pelkv/nnq9kp" target="_blank" rel="noopener noreferrer">https://www.yuque.com/shouhu-pelkv/nnq9kp</a></p><p>非常感谢若川大佬的阅读源码活动，原文：<a href="https://juejin.cn/post/6844904088220467213#heading-11" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844904088220467213#heading-11</a></p></blockquote><h3 id="_1-什么是co"><a class="header-anchor" href="#_1-什么是co" aria-hidden="true">#</a> 1. 什么是CO</h3><p>之前完全没有听说过CO是什么，简单的了解到它是利用了<code>ES6的generator和promise特性</code>实现了异步流程控制的一个库。简单的实现流程就是co在内部将<code>generator</code>对象的<code>next()</code>方法自动执行，实现<code>generator</code>函数的运行，并返回最终运行的结果。</p><h3 id="_2-阅读前准备"><a class="header-anchor" href="#_2-阅读前准备" aria-hidden="true">#</a> 2. 阅读前准备</h3><h4 id="_2-1-简单了解generator"><a class="header-anchor" href="#_2-1-简单了解generator" aria-hidden="true">#</a> 2.1 简单了解generator</h4><p>虽然<code>generator</code>函数是一个ES6提供的异步解决方案，但由于自己之前从来没有写过，所以需要“复习”下这块内容。</p><h5 id="_2-1-1-generator的声明"><a class="header-anchor" href="#_2-1-1-generator的声明" aria-hidden="true">#</a> 2.1.1 generator的声明</h5><p><code>generator</code>函数声明时与普通函数不一样的地方主要有两个点：</p><ul><li>function 与 函数名中间必须加一个* 号</li><li>定义内部状态时使用yield声明</li><li>function 与 函数名中间必须加一个* 号</li><li>定义内部状态时使用yield声明</li></ul><div class="language-"><pre><code>function* testGenerator() {\n\tyield &#39;test&#39;;\n  yield &#39;Gelx&#39;;\n  \n  return &#39;break&#39;;\n}\n\nlet run = testGenerator();\n</code></pre></div><h5 id="_2-1-2-generator的使用"><a class="header-anchor" href="#_2-1-2-generator的使用" aria-hidden="true">#</a> 2.1.2 generator的使用</h5><p>使用 <code>generator</code>函数时，函数并不会马上执行，它会指向内部状态的指针对象。如果要执行时，必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。</p><p>更详细的generator函数介绍可以参考<a href="https://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener noreferrer">Generator函数的语法</a></p><h3 id="_3-开始阅读"><a class="header-anchor" href="#_3-开始阅读" aria-hidden="true">#</a> 3. 开始阅读</h3><h4 id="_3-1-阅读前疑问"><a class="header-anchor" href="#_3-1-阅读前疑问" aria-hidden="true">#</a> 3.1 阅读前疑问</h4><p>在简单的了解了co的作用以及<code>generator</code>的使用后，有以下几个疑问：</p><ul><li>怎么样实现依次调用next()方法</li><li>如何将<strong>yield</strong>后边运算异步结果返回给对应的变量</li></ul>',17),d=t('<ul><li>co自身怎么返回generator函数最后的return值</li></ul><h4 id="_3-2-开始阅读"><a class="header-anchor" href="#_3-2-开始阅读" aria-hidden="true">#</a> 3.2 开始阅读</h4><h5 id="_3-2-1-源码地址"><a class="header-anchor" href="#_3-2-1-源码地址" aria-hidden="true">#</a> 3.2.1 源码地址</h5><p>co的源码地址为：<a href="https://github.com/tj/co" target="_blank" rel="noopener noreferrer">https://github.com/tj/co</a></p><h4 id="_3-2-2-如何使用"><a class="header-anchor" href="#_3-2-2-如何使用" aria-hidden="true">#</a> 3.2.2 如何使用</h4><p>在项目的<code>Readme.md</code>中可以找到co的使用方法</p><div class="language-"><pre><code>co(function* () {\n  var result = yield Promise.resolve(true);\n  return result;\n}).then(function (value) {\n  console.log(value);\n}, function (err) {\n  console.error(err.stack);\n});\n</code></pre></div><p>用法也比较简单，调用co函数，里面接收了一个<code>generator</code>函数，同时这个函数中返回了一个Promise。</p><h4 id="_3-2-3-源码阅读"><a class="header-anchor" href="#_3-2-3-源码阅读" aria-hidden="true">#</a> 3.2.3 源码阅读</h4><div class="language-"><pre><code>function co(gen) {\n  var ctx = this;\n  // 剔除gen对象，保留其他的入参\n  var args = slice.call(arguments, 1);\n\n // 返回一个最外围的Promise\n  return new Promise(function(resolve, reject) {\n    // 判断gen是不是函数，以及判断gen.next是不是函数，不是函数则直接reslove\n    if (typeof gen === &#39;function&#39;) gen = gen.apply(ctx, args);\n    if (!gen || typeof gen.next !== &#39;function&#39;) return resolve(gen);\n\t\t// 执行第一次next\n    onFulfilled();\n    // 先执行gen.next，获取参数\n    function onFulfilled(res) {\n      var ret;\n      try {\n        ret = gen.next(res);\n      } catch (e) {\n        return reject(e);\n      }\n      // 将执行返回的结果传入next函数\n      next(ret);\n      return null;\n    }\n\t\t\n\t\t// 对gen.throw\n    function onRejected(err) {\n      var ret;\n      try {\n        ret = gen.throw(err);\n      } catch (e) {\n        return reject(e);\n      }\n      next(ret);\n    }\n\n\t\t// co中做的next执行\n    function next(ret) {\n      // 如果gen已经执行完毕，则直接返回结果\n      if (ret.done) return resolve(ret.value);\n      // 如果没有执行完成，就封装成Promise继续执行\n      var value = toPromise.call(ctx, ret.value);\n      // 判断value是否是Promise,如果是就继续执行，不是就Rejected\n      if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);\n      return onRejected(new TypeError(&#39;You may only yield a function, promise, generator, array, or object, &#39;\n        + &#39;but the following object was passed: &quot;&#39; + String(ret.value) + &#39;&quot;&#39;));\n    }\n  });\n}\n</code></pre></div><p>通过对源码的简单阅读，可以总结出co执行的过程如下：</p><ul><li>进入最外层promise</li><li>判断传入的gen、gen.next是否为函数，是则继续执行</li></ul>',12),s=o("ul",null,[o("li",null,[a("进入onFulfilled，并记录下"),o("code",null,"generator"),a("函数执行的第一个yield返回的参数，并将该参数传入next函数")]),o("li",null,"如果传入next函数的done为true，则返回最外层的promise的resolve")],-1),u=o("ul",null,[o("li",null,"如果传入next函数的done为false，则返回value，并判断该value是否可以转为内部promise对象，如果无法转移，则抛出错误，返回最外层promise的reject"),o("li",null,[a("如果可以转化为promise对象，则执行内部promise，通过"),o("code",null,".then(onFulfilled, onRejected)"),a("开始执行")])],-1),h=o("ul",null,[o("li",null,"继续在onFulfilled、onRejected内部继续调用next函数，执行yield"),o("li",null,"当所有的yield执行返回完毕后，将最后的return值返回给最外层promise的resolve")],-1),p=t('<ul><li>结束调用</li></ul><h4 id="_3-2-4-next函数"><a class="header-anchor" href="#_3-2-4-next函数" aria-hidden="true">#</a> 3.2.4 next函数</h4><p>在整个co执行的流程中，最重要的就是next函数，而next函数中最重要的一步则是转化为内部Promise对象，这部分的源码如下：</p><div class="language-"><pre><code>function toPromise(obj) {\n    // 确保obj有意义\n    if (!obj) return obj;\n    // 若是Promise对象，则直接返回\n    if (isPromise(obj)) return obj;\n    // 若是generator函数或者generator对象，则递归调用co函数\n    if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);\n    // 若是函数，则转化promise类函数后再返回\n    if (&#39;function&#39; == typeof obj) return thunkToPromise.call(this, obj);\n    // 若是数组，转化promise数组后返回\n    if (Array.isArray(obj)) return arrayToPromise.call(this, obj);\n    // 若是对象，转化promise对象后返回\n    if (isObject(obj)) return objectToPromise.call(this, obj);\n    return obj;\n}\n</code></pre></div><h3 id="_4-实现简单co"><a class="header-anchor" href="#_4-实现简单co" aria-hidden="true">#</a> 4. 实现简单co</h3><p>\\</p><h4 id="_4-1-实现简单模拟请求"><a class="header-anchor" href="#_4-1-实现简单模拟请求" aria-hidden="true">#</a> 4.1 实现简单模拟请求</h4><p>首先先实现通过调用Promise获取参数</p><div class="language-"><pre><code>function request(time) {\n\treturn new Promise(resolve =&gt; {\n  \tsetTimeout(()=&gt; {\n    \tresolve({name:&quot;瘦虎&quot;})\n    },time)\n  })\n}\n\n\n// 用yield获取请求到的值\n\nfunction* getData() {\n\tyield request()\n}\n</code></pre></div><h4 id="_4-2-实现简单co"><a class="header-anchor" href="#_4-2-实现简单co" aria-hidden="true">#</a> 4.2 实现简单co</h4><p>整个co核心功能有两点：</p><ul><li>参数传递</li><li>generator.next 自动执行</li></ul><div class="language-"><pre><code>function co(gen) {\n\t1. 获取参数\n  let ctx = this;\n  const args = Array.propotype.slice.call(arguments, 1);\n  gen = gen.apply(ctx,args);\n\treturn new Promise((resolve,reject) =&gt; {\n  \tonFulfilled()\n    \n    function onFulfilled(res) {\n    \tlet ret = gen.next(res);\n      next(ret);\n    }\n    \n    function next(ret) {\n    \tif(ret.done) return resolve(ret.value);\n      let promise = ret.value\n      \n      promise &amp;&amp; promise.then(onFulfilled);\n    }\n  })\n}\n\n// 最后效果\nco(function* getData() {\n\tlet res = yield request();\n  console.log(result)\n})\n</code></pre></div><h3 id=""><a class="header-anchor" href="#" aria-hidden="true">#</a></h3><h3 id="总结"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>这次阅读co花了很长的时间，原因在于除了需要了解co的整套执行逻辑外，还需要了解<code>generator</code>的使用方式、特性、执行规律，这样才能更好的理解为什么会有co函数。虽然源码不多，但看懂整套逻辑后，突然通透的感觉还是很舒服的，希望后续的阅读，我可以提升自己的阅读效率，更高效的完成学习。</p>',16);i.render=function(t,o,a,l,i,g){return e(),n("div",null,[c,r(""),d,r(""),s,r(""),u,r(""),h,r(""),p])};export{l as __pageData,i as default};
