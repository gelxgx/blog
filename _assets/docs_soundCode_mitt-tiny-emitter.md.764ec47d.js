import{q as e,g as n,l as a,K as t}from"./common-1984dd55.js";const i='{"title":"【源码计划第七期】mitt、tiny-emitter 发布订阅","frontmatter":{"date":"2021-11-30","title":"【源码计划第七期】mitt、tiny-emitter 发布订阅","tags":["源码"],"describe":"认识发布订阅模式"},"headers":[{"level":3,"title":"1.阅读前准备","slug":"_1-阅读前准备"},{"level":3,"title":"2.开始阅读","slug":"_2-开始阅读"},{"level":3,"title":"3.源码正文","slug":"_3-源码正文"},{"level":3,"title":"4.总结","slug":"_4-总结"}],"relativePath":"docs/soundCode/mitt-tiny-emitter.md","lastUpdated":1646063815125.8818}';var r={};const l=t('<h3 id="_1-阅读前准备"><a class="header-anchor" href="#_1-阅读前准备" aria-hidden="true">#</a> 1.阅读前准备</h3><p>这两个库都是在vue中非常熟悉、使用频率很高的事件传递方法之一，而Vue3.x版本移除了内置的$on、$off的方法，改用使用第三方库进行该方法的调用</p><p>阅读前先温习一下正常的使用方法：</p><h4 id="_1-1-使用方法"><a class="header-anchor" href="#_1-1-使用方法" aria-hidden="true">#</a> 1.1 使用方法</h4><p>首先 <strong>$on和$emit的事件必须在一个公共实例上才会被触发</strong> 。</p><p>在vue项目开发时，经常会遇到兄弟、爷孙组件的传值情况，此时通常会使用Vue实例作为中央事件处理总线，将事件放置在全局中触发</p><div class="language-"><pre><code>vue.prototype.$bus = new Vue();\n\nthis.$bus.$emit(&#39;test&#39;,&#39;gelx&#39;)\n\n// mounted中接受函数\nmounted() {\n\tthis.$bus.$on(&#39;test&#39;,info =&gt; {\n    console.log(info)\n  })\n}\n</code></pre></div><h4 id="_1-2-简单了解map"><a class="header-anchor" href="#_1-2-简单了解map" aria-hidden="true">#</a> 1.2 简单了解Map</h4><p>源码中大量使用的Map的方法，由于之前没有接触过Map，因此做一个小小的预习</p><h5 id="_1-2-1-什么是map"><a class="header-anchor" href="#_1-2-1-什么是map" aria-hidden="true">#</a> 1.2.1 什么是map</h5><p>Map对象保存键/值 对，是键/值对的集合</p><h5 id="_1-2-2与object对象的不同点"><a class="header-anchor" href="#_1-2-2与object对象的不同点" aria-hidden="true">#</a> 1.2.2与Object对象的不同点</h5><ul><li><p>Map的键可以是任意值</p></li><li><p>Map的键值是有顺序的，遍历时会按插入的顺序返回键值</p></li><li><p>通过size属性可以获取Map的键值对个数</p></li><li><p>Map可以进行迭代</p></li></ul><h5 id="_1-2-3常用的属性、方法"><a class="header-anchor" href="#_1-2-3常用的属性、方法" aria-hidden="true">#</a> 1.2.3常用的属性、方法</h5><ul><li><p>属性</p></li><li><ul><li>size 获取键值对数量</li></ul></li><li><p>方法</p></li><li><ul><li>clear() 清空map对象</li><li>delete(key) 移除某个指定元素</li></ul></li><li><ul><li>get(key) 返回某个指定元素</li><li>has(key) 检测是否存在某个元素</li></ul></li><li><ul><li>set(key,value) 添加至Map对象的key 键和对应的value 值</li></ul></li></ul><h3 id="_2-开始阅读"><a class="header-anchor" href="#_2-开始阅读" aria-hidden="true">#</a> 2.开始阅读</h3><p>今天主要有两部分源码</p><p>第一部分mitt: <a href="https://github.com/developit/mitt" target="_blank" rel="noopener noreferrer">https://github.com/developit/mitt</a></p><p>第二部分tiny-emitter: <a href="https://github.com/scottcorgan/tiny-emitter" target="_blank" rel="noopener noreferrer">https://github.com/scottcorgan/tiny-emitter</a></p><p>学习的目标就是了解和学习发布订阅者模式</p><h3 id="_3-源码正文"><a class="header-anchor" href="#_3-源码正文" aria-hidden="true">#</a> 3.源码正文</h3><h4 id="_3-1-miit源码阅读"><a class="header-anchor" href="#_3-1-miit源码阅读" aria-hidden="true">#</a> 3.1 miit源码阅读</h4><p>首先开始阅读mitt源码</p><p>具体源码目录如下，主要有两部分：源码主体、test测试用例</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f21b58adf35a494b95d456d71c61d1df~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>第一件事，<code>tsc src/index.ts</code></p><p>希望自己可以早点学会ts，进行ts源码阅读……</p><h5 id="_3-1-1-源码主体"><a class="header-anchor" href="#_3-1-1-源码主体" aria-hidden="true">#</a> 3.1.1 源码主体</h5><p>整个源码函数主要实现了四个功能：</p><p>1：接收一个外来参数，或直接新建一个Map对象</p><p>2：实现on函数</p><p>3：实现off函数</p><p>4：实现emit函数</p><div class="language-"><pre><code>function mitt(all) {\n    all = all || new Map();\n    return {\n        all: all,\n        on: function (type, handler) {\n            // code ...\n        },\n        off: function (type, handler) {\n            // code ...\n        },\n        emit: function (type, evt) {\n            // code ...\n        }\n    };\n}\n</code></pre></div><h5 id="_3-1-2-on-，它是一个订阅者订阅事件的函数"><a class="header-anchor" href="#_3-1-2-on-，它是一个订阅者订阅事件的函数" aria-hidden="true">#</a> 3.1.2 on()，它是一个订阅者订阅事件的函数</h5><div class="language-"><pre><code>on: function (type, handler) {\n  // 获取指定type对应的handler\n  var handlers = all.get(type);\n  // 如果存在，就为已有的处理上push一个新的handler\n  if (handlers) {\n    handlers.push(handler);\n  }\n  // 如果不存在，就新增一个type，且对应的处理由数组存放，为了方便添加多个处理\n  else {\n    all.set(type, [handler]);\n  }\n},\n</code></pre></div><h5 id="_3-1-3-off-，它是一个订阅者删除订阅事件的函数"><a class="header-anchor" href="#_3-1-3-off-，它是一个订阅者删除订阅事件的函数" aria-hidden="true">#</a> 3.1.3 off()，它是一个订阅者删除订阅事件的函数</h5><div class="language-"><pre><code>off: function (type, handler) {\n  // 同样获取指定type的handler\n  var handlers = all.get(type);\n  // 如果传入了handler\n  if (handlers) {\n    // 且这个type存在时\n    if (handler) {\n      // 会在type中寻找与传入的handler相对应的handler\n      // 如果存在，就会直接返回在数组中的位置，进行删除\n      // 如果不存在，就会直接返回原数组，这里下面会继续分析\n      handlers.splice(handlers.indexOf(handler) &gt;&gt;&gt; 0, 1);\n    }\n    // 如果没有传入handler\n    // 默认当前type下全部清空\n    else {\n      all.set(type, []);\n    }\n  }\n},\n</code></pre></div><p>这部分出现了一个 <code>&gt;&gt;&gt; 0</code> 的表达式，进一步了解这个表达式的意义</p><p>js中&gt;&gt;表示有符号位移，&gt;&gt;&gt;表示无符号位移</p><ul><li>有符号位移表示 右边移去一个0，左边补充一个1</li><li>无符号位移表示 右边移去一个0，左边补充一个0</li></ul><p>当需要操作正数的时候，是不会有差别的</p><p>但操作负数的时候，就会有非常大的差别</p><p>负数在二进制中的表达是以补码的形式存在，也就是正常的二进制码的反码再加+</p><p>负数进行无符号的位移时，会在左边补充一个0，变成了正数，也就是目前数组的长度，删除一个最大长度上的第一位（空值），所以这部分会将内容全部返回</p><h5 id="_3-1-4-emit-，它是一个发布者发布事件的函数"><a class="header-anchor" href="#_3-1-4-emit-，它是一个发布者发布事件的函数" aria-hidden="true">#</a> 3.1.4 emit()，它是一个发布者发布事件的函数</h5><div class="language-"><pre><code>emit: function (type, evt) {\n  // 获取指定type对应的handlers\n  var handlers = all.get(type);\n  // 如果存在\n  if (handlers) {\n    // 浅拷贝handlers，并循环对所有handler执行参数为evt的方法\n    handlers\n      .slice()\n      .map(function (handler) {\n      handler(evt);\n    });\n  }\n  // 如果不存在\n  // 找全局上绑定的handlers\n  handlers = all.get(&#39;*&#39;);\n  // 如果全局上纯在handlers\n  // 依次进行执行，并传递当前触发的type\n  if (handlers) {\n    handlers\n      .slice()\n      .map(function (handler) {\n      handler(type, evt);\n    });\n  }\n}\n</code></pre></div><p>这部分的emit仅可传递一个参数，如果需要传递多个参数，需要以对象或数组的形式传入</p><h4 id="_3-2-1-tiny-emitter-部分"><a class="header-anchor" href="#_3-2-1-tiny-emitter-部分" aria-hidden="true">#</a> 3.2.1 tiny-emitter 部分</h4><p>这个工具库实现的功能与mitt大同小异，同样实现了<code>$on $once $off $emit</code>的功能，但具体的使用上会有一些小的差异</p><h5 id="_3-2-2-使用方式"><a class="header-anchor" href="#_3-2-2-使用方式" aria-hidden="true">#</a> 3.2.2 使用方式</h5><p>先看看官方文档给出的使用案例：</p><div class="language-"><pre><code>var Emitter = require(&#39;tiny-emitter&#39;);\nvar emitter = new Emitter();\n\nemitter.on(&#39;some-event&#39;, function (arg1, arg2, arg3) {\n //\n});\n\nemitter.emit(&#39;some-event&#39;, &#39;arg1 value&#39;, &#39;arg2 value&#39;, &#39;arg3 value&#39;);\n</code></pre></div><p>从这里就可以看到与miit一个比较大的不同是：emit可以传递多个参数</p><h5 id="_3-2-3-源码阅读"><a class="header-anchor" href="#_3-2-3-源码阅读" aria-hidden="true">#</a> 3.2.3 源码阅读</h5><p>\\</p><p>首先依旧是<code>tsc index.d.ts</code></p><p>这个库是定义了一个空的函数，通过在它的原型上定义了4种方法：</p><ul><li>on()</li><li>once()</li></ul>',59),d=t('<ul><li>emit()</li><li>off()</li></ul><div class="language-"><pre><code>function E () {\n  // Keep this empty so it&#39;s easier to inherit from\n  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n}\n\nE.prototype = {\n  on: function (name, callback, ctx) {\n    //code...\n  },\n\n  once: function (name, callback, ctx) {\n    //code...\n  },\n\n  emit: function (name) {\n    // code...\n  },\n\n  off: function (name, callback) {\n    // code...\n  }\n};\n</code></pre></div><h5 id="_3-2-4-on-订阅事件"><a class="header-anchor" href="#_3-2-4-on-订阅事件" aria-hidden="true">#</a> 3.2.4 on() 订阅事件</h5><div class="language-"><pre><code>on: function (name, callback, ctx) {\n  \t// 判断是否存在e,如果不存在，就是用空对象 \n  \t// mitt是用的是Map\n    var e = this.e || (this.e = {});\n  \t// 并判断传入的name是否存在，用数组的方式存储\n    (e[name] || (e[name] = [])).push({\n      fn: callback,\n      ctx: ctx\n    });\n\t\t// 返回this，保持上下文依旧可以调用\n    return this;\n  },\n</code></pre></div><h5 id="once-只执行一次订阅时间"><a class="header-anchor" href="#once-只执行一次订阅时间" aria-hidden="true">#</a> once() 只执行一次订阅时间</h5><div class="language-"><pre><code>once: function (name, callback, ctx) {\n    var self = this;\n    function listener () {\n      // 执行完成后调用off注销事件\n      self.off(name, listener);\n      callback.apply(ctx, arguments);\n    };\n\n    listener._ = callback\n    return this.on(name, listener, ctx);\n  },\n</code></pre></div><h5 id="emit-发布事件"><a class="header-anchor" href="#emit-发布事件" aria-hidden="true">#</a> emit() 发布事件</h5><div class="language-"><pre><code>emit: function (name) {\n  // 创建一个data数组，并获取参数，这里可以拿到多个参数\n  var data = [].slice.call(arguments, 1);\n  var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n  var i = 0;\n  var len = evtArr.length;\n\n  for (i; i &lt; len; i++) {\n    // 遍历执行回调函数，并接收传入的data参数\n    evtArr[i].fn.apply(evtArr[i].ctx, data);\n  }\n\n  return this;\n},\n</code></pre></div><h5 id="off-取消事件绑定"><a class="header-anchor" href="#off-取消事件绑定" aria-hidden="true">#</a> off() 取消事件绑定</h5><div class="language-"><pre><code>off: function (name, callback) {\n    var e = this.e || (this.e = {});\n  \t// 获取e上name中对应的所有的回调函数\n    var evts = e[name];\n    var liveEvents = [];\n\t\t// 如果off传入了回调函数\n    if (evts &amp;&amp; callback) {\n      // 会遍历name中所有的函数\n      for (var i = 0, len = evts.length; i &lt; len; i++) {\n        \t// 如果存在与传入的回调函数不同的函数，就push进数组中\n        if (evts[i].fn !== callback &amp;&amp; evts[i].fn._ !== callback)\n          liveEvents.push(evts[i]);\n      }\n    }\n  \t// 最后如果这个数组存在内容，就保留继续执行，如果不存在，就整个删掉\n    (liveEvents.length)\n      ? e[name] = liveEvents\n      : delete e[name];\n\n    return this;\n  }\n</code></pre></div><h3 id="_4-总结"><a class="header-anchor" href="#_4-总结" aria-hidden="true">#</a> 4.总结</h3><p>通过阅读这两个开源库也学到了：</p><ul><li><p>Map的具体用法，与Object的异同点</p></li><li><p>发布订阅的设计模式</p></li><li><p>事件传递的原理，也能在实际工作中使用时，更清楚为什么要这么使用</p></li></ul>',13);r.render=function(t,i,r,h,c,p){return e(),n("div",null,[l,a(""),d])};export{i as __pageData,r as default};
