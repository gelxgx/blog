import{q as e,g as n,l as o,K as r,j as l}from"./common-1984dd55.js";const t='{"title":"【源码第四期】理解koa-compose","frontmatter":{"date":"2021-11-08","title":"【源码第四期】理解koa-compose","tags":["源码"],"describe":"浅析 koa-compose 中间件原理"},"headers":[{"level":3,"title":"1. 阅读前准备","slug":"_1-阅读前准备"},{"level":3,"title":"2. 学习目标","slug":"_2-学习目标"},{"level":3,"title":"3.开始阅读","slug":"_3-开始阅读"},{"level":3,"title":"4.总结","slug":"_4-总结"}],"relativePath":"docs/soundCode/koa-compose.md","lastUpdated":1646063815125.8818}';var i={};const a=r('<blockquote><p>非常感谢若川大佬的阅读源码活动，原文：<a href="https://juejin.cn/post/7005375860509245471" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/7005375860509245471</a></p></blockquote><h3 id="_1-阅读前准备"><a class="header-anchor" href="#_1-阅读前准备" aria-hidden="true">#</a> 1. 阅读前准备</h3><p>在阅读之前有简单的了解过koa,以及中间件的执行过程，并且也在上一期活动中通过CO源码的阅读，加深了next()函数的执行原理。今天看看koa-compoes做了一些什么操作。</p><h3 id="_2-学习目标"><a class="header-anchor" href="#_2-学习目标" aria-hidden="true">#</a> 2. 学习目标</h3><p>本次阅读学习主要有以下几个目标：</p><ul><li>阅读源码，了解代码意义</li><li>对比co源码，解决了什么问题</li></ul><h3 id="_3-开始阅读"><a class="header-anchor" href="#_3-开始阅读" aria-hidden="true">#</a> 3.开始阅读</h3><p>koa-compose项目主要分为两部分：</p><ul><li>jest的test测试用例部分</li><li>index.js koa-compose主文件</li></ul><p>直接进入index.js 开读！</p><p>这里只有短短不到50行的代码，compose函数结构上看，通过闭包的形式完成了整个功能</p><p>具体代码如下：</p><p>这里分为两部分：</p><ul><li>第一部分校验参数</li><li>第二部分接收参数并返回Promise</li></ul><div class="language-"><pre><code>function compose (middleware) {\n  if (!Array.isArray(middleware)) throw new TypeError(&#39;Middleware stack must be an array!&#39;)\n  for (const fn of middleware) {\n    if (typeof fn !== &#39;function&#39;) throw new TypeError(&#39;Middleware must be composed of functions!&#39;)\n  }\n\n  /**\n   * @param {Object} context\n   * @return {Promise}\n   * @api public\n   */\n\n  return function (context, next) {\n    // last called middleware #\n    let index = -1\n    return dispatch(0)\n    function dispatch (i) {\n    }\n  }\n}\n</code></pre></div><p>第一部分很好理解，首先对接收到的参数进行两次判断：</p><ul><li>如果这个参数不是数组，则抛出错误</li><li>如果这个数组参数中的每一项都不是函数时，则抛出错误</li></ul>',17),s=l("ul",null,[l("li",null,"如果这个参数是数组，且数组中的每一项都是函数时，则继续往下执行dispatch函数")],-1),c=l("div",{class:"language-"},[l("pre",null,[l("code",null,"function dispatch (i) {\n      if (i <= index) return Promise.reject(new Error('next() called multiple times'))\n      index = i\n      let fn = middleware[i]\n      if (i === middleware.length) fn = next\n      if (!fn) return Promise.resolve()\n      try {\n        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)))\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n")])],-1),d=l("p",null,"dispatch函数做了以下这些事：",-1),p=l("ul",null,[l("li",null,"首先判断是否存在next()多次调用的情况，如果存在则会直接报错"),l("li",null,"接着陆续取出middlewatre中的第1、2、3...个函数并开始执行")],-1),u=l("ul",null,[l("li",null,"如果检测到为最后一个时，next为undefined，此时fn不是函数，直接返回resolve"),l("li",null,"如果不是最后一个，则也会返回一个resolve，但resolve内容是取到下一个middleware中的函数")],-1),m=r('<ul><li>当执行到next()函数时，会重新return进入dispatch函数内部，继续执行下一个函数</li><li>直到最后一个函数时，fn为undefined，直接resolve</li></ul><p>一句话总结：嵌套调用Promise.resolve，往里深入，执行完毕后，从底部再重新往上执行</p><p>于是我简化了一下compose，这样能更方便理解：</p><div class="language-"><pre><code>const [t1, t2, t3] = stack;\nconst testC = function(context){\n    await Promise.resolve(\n      t1(context, function next(){\n        return Promise.resolve(\n          t2(context, function next(){\n              return Promise.resolve(\n                  t3(context, function next(){\n                    return Promise.resolve();\n                  })\n              )\n          })\n        )\n    })\n  );\n};\n</code></pre></div><h3 id="_4-总结"><a class="header-anchor" href="#_4-总结" aria-hidden="true">#</a> 4.总结</h3><p>虽然koa-compose源码不多，但设计非常精巧，一个</p><p><code>return Promise.resolve(fn(context, dispatch.bind(null, i + 1)))</code></p><p>就将所有的中间件串联了起来</p><p>我也能加深对中间件的理解，以前只知道怎么使用，现在可以知道这其中的原理。</p><h4 id="_4-1-与co的对比"><a class="header-anchor" href="#_4-1-与co的对比" aria-hidden="true">#</a> 4.1 与co的对比</h4><p>相同点：</p><p>co与koa-compose都同样通过使用promise完成了串联和调用。</p><p>不同点：</p><p>co传入的是一个<code>generator</code>，koa-compose传入的是一个普通函数</p><p>co通过promise自动执行<code>generator</code>的next函数，koa-compose则是通过一个闭包，将promise嵌套在内部并执行</p>',15);i.render=function(r,l,t,i,h,f){return e(),n("div",null,[a,o(""),s,c,d,p,o(""),u,o(""),m])};export{t as __pageData,i as default};
