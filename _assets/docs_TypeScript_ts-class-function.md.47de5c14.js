import{q as e,g as n,l as r,K as a}from"./common-1984dd55.js";const t='{"title":"【TypeScript第二期】类、函数、泛型、枚举","frontmatter":{"date":"2021-11-30","title":"【TypeScript第二期】类、函数、泛型、枚举","tags":["TypyScript"],"describe":"学习 TS类、函数、泛型、枚举"},"headers":[{"level":3,"title":"1.类","slug":"_1-类"},{"level":3,"title":"","slug":""},{"level":3,"title":"2. 函数","slug":"_2-函数"},{"level":3,"title":"3. 泛型","slug":"_3-泛型"},{"level":3,"title":"","slug":"-2"},{"level":3,"title":"","slug":"-3"},{"level":3,"title":"4.枚举","slug":"_4-枚举"}],"relativePath":"docs/TypeScript/ts-class-function.md","lastUpdated":1646063815125.8818}';var i={};const d=a('<h3 id="_1-类"><a class="header-anchor" href="#_1-类" aria-hidden="true">#</a> 1.类</h3><p>TS中有以下这些的用法：</p><ul><li><p>public 公有，可以在任何地方被访问，默认属性</p></li><li><p>private 私有，不能被外部访问</p></li><li><p>protected 受保护的，在子类中是允许被访问的</p></li><li><p>readonly</p></li><li><p>参数属性</p></li><li><p>抽象类</p></li><li><p>类的接口</p></li></ul><h4 id="_1-1-public"><a class="header-anchor" href="#_1-1-public" aria-hidden="true">#</a> 1.1 public</h4><p>这是一个默认的修饰符，具体写法：</p><p>它可以被所有人访问和继承</p><div class="language-"><pre><code>class people {\n\tpublic name: string;\n  public constructor(theName:string){\n  \tthis.name = theName;\n  }\n\tpublic move(age: number) {\n  \tconsole.log(`${this.name} age is ${age}`)\n  }\n}\n</code></pre></div><h4 id="_1-2-private"><a class="header-anchor" href="#_1-2-private" aria-hidden="true">#</a> 1.2 private</h4><p>当构造函数的修饰符定义为<code>private</code>时，该类不允许被继承或实例化</p><div class="language-"><pre><code>class people {\n\tprivate name: string;\n  public constructor(theName:string){\n  \tthis.name = theName;\n  }\n\tpublic move(age: number) {\n  \tconsole.log(`${this.name} age is ${age}`)\n  }\n}\n\nnew people(&#39;boy&#39;).name // error报错 是私有的，不允许访问\n</code></pre></div><h4 id="_1-3-protected"><a class="header-anchor" href="#_1-3-protected" aria-hidden="true">#</a> 1.3 protected</h4><p>我理解这是介于<code>public</code>与<code>private</code>之间的一个属性，在子类中可以访问、继承，但不能直接被实例化</p><div class="language-"><pre><code>class prople {\n    protected name: string;\n    protected constructor(theName: string) {\n      this.name = theName; \n    }\n}\n\nclass boy extends people {\n    private like: string;\n\n    constructor(name: string, like: string) {\n        super(name);\n        this.like = like;\n    }\n\n    public getLike() {\n        return `Hello, my name is ${this.name} and I like ${this.like}.`;\n    }\n}\n\nlet gelx = new boy(&quot;gelx&quot;, &quot;drink&quot;);\nlet girl = new people(&quot;red&quot;); // 错误: &#39;people&#39; 的构造函数是被保护的.\n</code></pre></div><h4 id="_1-4-readonly"><a class="header-anchor" href="#_1-4-readonly" aria-hidden="true">#</a> 1.4 readonly</h4><p>设置为只读属性，只读属性必须在声明时或构造函数初始化时声明参数，否则都会报错</p><div class="language-"><pre><code>class boy {\n    readonly name: string;\n    readonly age: number = 18;\n    constructor (theName: string) {\n        this.name = theName;\n    }\n}\n\nlet gelx = new boy(&#39;gelx&#39;)\ngelx.age = 23; // error age是只读的\n</code></pre></div><h4 id="_1-5-参数属性"><a class="header-anchor" href="#_1-5-参数属性" aria-hidden="true">#</a> 1.5 参数属性</h4><p>以上四种属性设置时，可以使用参数属性提升代码简洁</p><p>简化一下上面的例子</p><div class="language-"><pre><code>class boy {\n  readonly age: number = 18;\n\tpublic constructor (public name: string) {\n  \n  }\n}\n</code></pre></div><p>直接在构造方法中传入一个属性，TS会直接将其翻译成，定义一个属性-传入一个属性-属性复制</p><h4 id="_1-6-抽象类"><a class="header-anchor" href="#_1-6-抽象类" aria-hidden="true">#</a> 1.6 抽象类</h4><p>声明类前添加一个<code>abstract</code>表示该类为抽象类</p><p>抽象类不能被实例化</p><div class="language-"><pre><code>abstract class people {\n  public constructor(public name: string) {}\n  public abstract sayHi();\n}\n\nlet boy = new people(&#39;gelx&#39;); // error！不能被实例化\n</code></pre></div><p>抽象类中的抽象方法必须被子类实现</p><div class="language-"><pre><code>abstract class people {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n  public abstract sayHi();\n}\n\nclass boy extends people {\n\tpubilic sayHi() {\n  \tconsole.log(`my name is ${this.name}`)\n  }\n}\n</code></pre></div><h4 id="_1-7-类的接口使用"><a class="header-anchor" href="#_1-7-类的接口使用" aria-hidden="true">#</a> 1.7 类的接口使用</h4><p>类定义会创建两个东西：类的<strong>实例类型</strong>和一个<strong>构造函数</strong>。 因为类可以创建出实例类型，所以可以在允许使用接口的地方使用类。</p><div class="language-"><pre><code>class Point {\n    x: number;\n    y: number;\n}\n\ninterface Point3d extends Point {\n    z: number;\n}\n\nlet point3d: Point3d = {x: 1, y: 2, z: 3};\n</code></pre></div><h3 id=""><a class="header-anchor" href="#" aria-hidden="true">#</a></h3><h3 id="_2-函数"><a class="header-anchor" href="#_2-函数" aria-hidden="true">#</a> 2. 函数</h3><p>TS中函数有一些不一样的用法：</p><ul><li><p>表达式</p></li><li><p>用接口定义函数</p></li><li><p>可选参数、参数默认值、剩余参数</p></li><li><p>重载</p></li></ul><h4 id="_2-1-表达式"><a class="header-anchor" href="#_2-1-表达式" aria-hidden="true">#</a> 2.1 表达式</h4><p>一个正常的有输入输出的TS函数表达式：</p><div class="language-"><pre><code>function add(x:number, y:number):number {\n\treturn x+y;\n}\nadd(2,3)\n</code></pre></div><p>如果定义一个参数为函数表达式：</p><div class="language-"><pre><code>let count = function (x:number, y:number):number {\n\treturn x+y;\n}\n</code></pre></div><p>当然这种写法，左边的参数无法得到校验，因此通过以下写法，使得左边参数得到校验：</p><div class="language-"><pre><code>let count(x:number, y:number) =&gt; number = function (x:number, y:number):number {\n\treturn x+y;\n}\n</code></pre></div><p>此时所用到的<code>=&gt;</code> 与ES6中的<code>=&gt;</code>不是同一个意思</p><p>TS类型定义中的<code>=&gt;</code>表示函数的定义，左边为输入的类型，右边为输出的类型</p><h4 id="_2-2-用接口定义函数"><a class="header-anchor" href="#_2-2-用接口定义函数" aria-hidden="true">#</a> 2.2 用接口定义函数</h4><p>定义输入类型时，可以通过接口的方式定义一个输入类型的集合</p><div class="language-"><pre><code>interface addFunc {\n\t(x: number, y: number):boolean;\n}\n\nlet count: addFunc =&gt; number = function (x:number, y:number):number {\n\treturn x+y;\n}\n</code></pre></div><h4 id="_2-3-可选参数、参数默认值、剩余参数"><a class="header-anchor" href="#_2-3-可选参数、参数默认值、剩余参数" aria-hidden="true">#</a> 2.3 可选参数、参数默认值、剩余参数</h4><h5 id="_2-3-1-可选参数"><a class="header-anchor" href="#_2-3-1-可选参数" aria-hidden="true">#</a> 2.3.1 可选参数</h5><p>函数中同样可以使用<code>？</code>表示改参数是否可选。</p><p><strong>但可选参数后不允许再出现必选参数</strong></p><hr><div class="language-"><pre><code>function consoleName(fName: string, lName?: string) {\n\tif (lName) {\n        return fName + &#39; &#39; + lName;\n    } else {\n        return fName;\n    }\n}\n\nlet gelx = consoleName(&#39;g&#39;,&#39;x&#39;)\nlet gelx = consoleName(&#39;g&#39;)\n</code></pre></div><hr><h5 id="_2-3-2-参数默认值"><a class="header-anchor" href="#_2-3-2-参数默认值" aria-hidden="true">#</a> 2.3.2 参数默认值</h5><p>同样的，可以在传入参数时，设置一个默认值</p><div class="language-"><pre><code>function consoleName(fName: string = &#39;gelx&#39;, lName: string) {\n\tif (lName) {\n        return fName + &#39; &#39; + lName;\n    } else {\n        return fName;\n    }\n}\n\nlet gelx = consoleName(&#39;g&#39;,&#39;x&#39;)\nlet gelx = consoleName(&#39;g&#39;)\n</code></pre></div><h5 id="_2-3-3-剩余参数"><a class="header-anchor" href="#_2-3-3-剩余参数" aria-hidden="true">#</a> 2.3.3 剩余参数</h5><p>在ES6中，如果不知道具体会传递多少参数，可以使用<code>arguments</code>获取到所有传入的参数，同样在TypeScript中，可以把这些所有参数聚集在一个变量中，并以数组的方式存储。</p><p><strong>使用时仍需要注意，聚集的参数同样也只能被放在最后使用</strong></p><div class="language-"><pre><code>function name(fName: string , ...mName: stringp[]) {\n\treturn `${fName} ${mName.join(&quot;&quot;)}`\n}\n</code></pre></div><h4 id="_2-4-重载"><a class="header-anchor" href="#_2-4-重载" aria-hidden="true">#</a> 2.4 重载</h4><p>允许一个函数接受不同数量或类型的参数时，作出不同的处理。当我们需要用到集合类型时，会比较体现出重载的意义</p><p>假如此时需要实现一个内容翻转的功能，可以对数字和字符串进行翻转</p><div class="language-"><pre><code>function reverse(x: number | string): number | string | void {\n    if (typeof x === &#39;number&#39;) {\n        return Number(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));\n    } else if (typeof x === &#39;string&#39;) {\n        return x.split(&#39;&#39;).reverse().join(&#39;&#39;);\n    }\n}\n</code></pre></div><p>这么写不能够精准表达输入为数字时，输出也为数字</p><p>所以可以通过重复定义函数，并在最后一次进行函数的实现</p><div class="language-"><pre><code>function reverse(x: number): number;\nfunction reverse(x: string): string;\nfunction reverse(x: number | string): number | string | void {\n    if (typeof x === &#39;number&#39;) {\n        return Number(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));\n    } else if (typeof x === &#39;string&#39;) {\n        return x.split(&#39;&#39;).reverse().join(&#39;&#39;);\n    }\n}\n</code></pre></div><h3 id="_3-泛型"><a class="header-anchor" href="#_3-泛型" aria-hidden="true">#</a> 3. 泛型</h3><p>泛型为了解决当我们在定义函数、接口、类时，对不确定类型的传入参数，进行类型指定和保护，确保定义、返回值的类型是统一的。</p><h4 id="_3-1-基础写法"><a class="header-anchor" href="#_3-1-基础写法" aria-hidden="true">#</a> 3.1 基础写法</h4><p>对于一个参数的写法，是下面这样的基础写法</p><div class="language-"><pre><code>function test&lt;T&gt;(name: T):T {\n\treturn name\n}\n</code></pre></div><p>也可以通过定义参数的方式声明泛型函数</p><div class="language-"><pre><code>let myTest: &lt;T&gt;(name: T) =&gt; T = test\n</code></pre></div><p>\\</p><p>当需要定义多个类型时，同样也可以定义多个泛型：</p><div class="language-"><pre><code>function testArr&lt;T,U&gt;(arr: [T,U]):[U,T] {\n\treturn [arr[1], arr[0]]\n}\n</code></pre></div><h4 id="_3-2-泛型约束"><a class="header-anchor" href="#_3-2-泛型约束" aria-hidden="true">#</a> 3.2 泛型约束</h4><p>可以通过创建一个接口描述泛型的约束条件，并通过<code>extends</code>继承方式来实现约束</p><div class="language-"><pre><code>interface Lengthwise {\n\tlength: number\n}\nfunction cLength&lt;T extends Lengthwise&gt;(num: T): T {\n\tconsole.log(num.length)\n}\n\ncLength({length:10, value: 3})\n</code></pre></div><p>由于使用了<code>extends</code>约束泛型<code>T</code>必须符合接口 Lengthwise 的形状，所以传入的参数必须包含 <code>length</code> 属性</p><p>同样可以实现多个参数的相互约束</p><div class="language-"><pre><code>function getProperty(obj: T, key: K) {\n    return obj[key];\n}\n\nlet x = { a: 1, b: 2, c: 3, d: 4 };\ngetProperty(x, &quot;a&quot;)\n</code></pre></div><h4 id="_3-3-泛型类"><a class="header-anchor" href="#_3-3-泛型类" aria-hidden="true">#</a> 3.3 泛型类</h4><p>同样泛型可以在类中进行定义</p><div class="language-"><pre><code>class GenericNumber&lt;T&gt; {\n    zeroValue: T;\n    add: (x: T, y: T) =&gt; T;\n}\n\nlet myGenericNumber = new GenericNumber&lt;number&gt;();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function(x, y) { return x + y; };\n</code></pre></div><h3 id="-2"><a class="header-anchor" href="#-2" aria-hidden="true">#</a></h3><h3 id="-3"><a class="header-anchor" href="#-3" aria-hidden="true">#</a></h3><h3 id="_4-枚举"><a class="header-anchor" href="#_4-枚举" aria-hidden="true">#</a> 4.枚举</h3><p>枚举又被分为四类：</p><ul><li>数字枚举</li><li>字符串枚举</li></ul>',91),c=a('<ul><li>常数枚举</li><li>外部枚举</li></ul><h4 id="_4-1-数字枚举"><a class="header-anchor" href="#_4-1-数字枚举" aria-hidden="true">#</a> 4.1 数字枚举</h4><p>通过使用<code>enum</code>定义一个枚举</p><div class="language-"><pre><code>enum Direction {\n    Up,\n    Down,\n    Left,\n    Right\n}\n</code></pre></div><p>访问枚举时，可以通过枚举的属性、名字来访问枚举类型</p><h5 id="_4-2-字符串枚举"><a class="header-anchor" href="#_4-2-字符串枚举" aria-hidden="true">#</a> 4.2 字符串枚举</h5><div class="language-"><pre><code>enum Direction {\n    Up = &quot;UP&quot;,\n    Down = &quot;DOWN&quot;,\n    Left = &quot;LEFT&quot;,\n    Right = &quot;RIGHT&quot;,\n}\n</code></pre></div><p>\\</p><h4 id="_4-3-常数枚举"><a class="header-anchor" href="#_4-3-常数枚举" aria-hidden="true">#</a> 4.3 常数枚举</h4><p>使用<code>const enum</code>代表常数枚举，常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员</p><div class="language-"><pre><code>const enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\n</code></pre></div><h4 id="-4"><a class="header-anchor" href="#-4" aria-hidden="true">#</a></h4><h4 id="_4-4-外部枚举"><a class="header-anchor" href="#_4-4-外部枚举" aria-hidden="true">#</a> 4.4 外部枚举</h4><p>使用<code>declare</code>定义外部枚举，它只会用于编译时的检查，编译结果中会被删除</p><div class="language-"><pre><code>declare enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\n</code></pre></div>',15);i.render=function(a,t,i,l,o,s){return e(),n("div",null,[d,r(""),c])};export{t as __pageData,i as default};
